# example5

## 문제

```text
N개의 양의 정수와 K의 배열 A가 주어집니다. 
A의 서로 다른 위치에 있는 K 원소의 가능한 최대 짝수 합을 구하시오. 

예를 들어, 
A = [4, 9, 8, 2, 6] 및 K = 3에서 세 원소의 최대 짝수 합은 18입니다. 
선택된 세 가지 요소는 A[0] = 4, A[2] = 8 및 A[4] = 6입니다. 

class 솔루션 { public int 솔루션(int[] A, int K); } N개의 양의 정수와 양의 정수 K의 배열 A가 주어졌을 때, K 원소의 가장 큰 짝수 합을 반환한다. 

이러한 K 요소가 없으면 -1을 반환합니다. 

    1. A = [4, 9, 8, 2, 6] 및 K = 3이 주어졌을 때, 함수는 위에서 설명한 바와 같이 18을 반환해야 한다. 
    2. A = [5, 6, 3, 4, 2]와 K = 5가 주어졌을 때, 함수는 20을 반환해야 한다. 다섯 개의 요소가 있고 그것들은 모두 20개이다. 
    3. A = [7, 7, 7, 7, 7] 및 K = 1일 때, 함수는 -1을 반환해야 합니다. 왜냐하면 우리는 하나의 원소만 선택할 수 있고 짝수는 없기 때문입니다. 
    4. A = [λ] 및 K = 2일 때, K가 N보다 크기 때문에 함수는 -1을 반환해야 합니다. 
    5. A = [2, 3, 3, 5, 5], K = 3일 때, 함수는 5 + 5 + 2 = 12이므로 12를 반환해야 합니다. 

다음 가정에 대한 효율적인 알고리즘을 작성합니다. 

N과 K는 [1~100000] 범위 내의 정수입니다.
배열 A의 각 요소는 [1~10000] 범위 내의 정수입니다.
```

## 요약

> 핵심 아이디어는 K개를 고른 합이 짝수가 되려면:
>
> 짝수 개수 개수(E) 중에서 x개,
> 홀수 개수 개수(O) 중에서 y개,
> 단, x + y = K 이고,
> y는 짝수(0, 2, 4 …) 여야 합니다.
>
> 즉, 홀수 개수를 짝수 개만 선택해야 전체 합이 짝수가 됩니다.

## 실행

```sh
cargo run
   Compiling example5 v0.1.0 (/rust-study/example5)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.05s
     Running `target/debug/example5`

A=[4, 9, 8, 2, 6], K=3 → 18
A=[5, 6, 3, 4, 2], K=5 → 20
A=[7, 7, 7, 7, 7], K=1 → -1
A=[2], K=2 → -1
A=[2, 3, 3, 5, 5], K=3 → 12
```
