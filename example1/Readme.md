# 문제1

## 들어가기

이 연습 문제는 Rust를 하나도 모르는 상태에서 ChatGPT를 이용해서, 러스트를 학습하고, 학습된 결과를 Github에 남기는 프로젝트입니다.

초심자의 입장에 리뷰시에 도움이 되도록 자세한 주석을 예제에 첨부하였습니다.

## 요약

N개의 양의 정수로 구성된 배열 A와 K라는 정수가 주어졌습니다. A의 서로 다른 위치에 있는 K개의 원소의 가장 큰 짝수 합을 구하세요.

예를 들어, A = [4, 9, 8, 2, 6]이고 K = 3일 때, 세 원소의 가장 큰 짝수 합은 18입니다. 선택된 세 원소는 A[0] = 4, A[2] = 8, A[4] = 6입니다.

다음 함수를 작성하세요.

> class Solution { public int solution(int[] A, int K); }

N개의 양의 정수로 구성된 배열 A와 K라는 양의 정수가 주어졌을 때, K개의 원소의 가장 큰 짝수 합을 반환합니다. 짝수 합이 존재하지 않으면 -1을 반환합니다.

예:

1. A = [4, 9, 8, 2, 6]이고 K = 3일 때, 위에서 설명한 대로 함수는 18을 반환해야 합니다.
2. A = [5, 6, 3, 4, 2]이고 K = 5일 때, 함수는 20을 반환해야 합니다. 5개의 요소가 있고 그 합은 20입니다.
3. A = [7, 7, 7, 7, 7]이고 K = 1일 때, 함수는 -1을 반환해야 합니다. 원소는 하나만 선택할 수 있고 짝수가 없기 때문입니다.
4. A = [10000]이고 K = 2일 때, 함수는 -1을 반환해야 합니다. K가 N보다 크기 때문입니다.
5. A = [2, 3, 3, 5, 5]이고 K = 3일 때, 함수는 5 + 5 + 2 = 12이므로 12를 반환해야 합니다.

다음 가정에 대한 효율적인 알고리즘을 작성하십시오.

> N과 K는 [1..100,000] 범위의 정수입니다. 배열 A의 각 요소는 [1..10,000] 범위의 정수입니다.

📌 짝수 합계 (Rust)

주어진 배열에서 K개의 요소를 선택해 만들 수 있는 가장 큰 짝수 합을 계산하는 Rust 기반 CLI 도구입니다.
예를 들어:

```sh
A = [4, 9, 8, 2, 6], K = 3 → 결과: 18
```

## 📁 프로젝트 구조

```sh
example1/
├── Cargo.toml  # cargo new <example1> 으로 자동생성
├── Makefile    # Gnu Make 설정파일
├── README.md   # 현재 파일
└── target/     # 빌드후 실행파일 생성되는 파일 (기본)
│   └── debug   # Cargo build 시 
│   └── release # Cargo build --release 
└── src/        # 실제 소스 파일
    └── main.rs # 메인 러스트 파일
    └── lib.rs  # 로직등을 분리한 러스트 파일    
```

## 🚀 빌드 & 실행 방법

이 프로젝트는 cargo 를 사용하여 빌드되며, Makefile 로 더 편하게 실행할 수 있습니다.

## 🛠️ Makefile 사용

> Rust를 몰라도 쉽게 빌드/실행 가능하도록 구성되어 있습니다.

Rust에서는 Cargo라는 관리툴이 있습니다.
하지만 기존의 C/C++사용하시던 분들은 Make 가 더 편리할 수 있습니다.

### ✔ 빌드 (Release 모드)

```sh
make build # cargo build --release 와 동일
```

### ✔ 디버그 빌드

```sh
make debug # cargo build 와 동일
```

### ✔ 실행

```sh
make run ARGS="4 9 8 2 6 3"
```

### ✔ 테스트 실행

```sh
make test  # cargo test 와 동일
```

### ✔ 클린

```sh
make clean # cargo clean 와 동일
```

### ✔ 시스템 전체에 설치

( /usr/local/bin 에 바이너리 설치 )

```sh
sudo make install
```

## 🧩 알고리즘 요약

목표:
배열 A 에서 서로 다른 위치의 K개 요소를 골라 짝수 합이 되도록 하고, 그중 가장 큰 값을 찾는다.

핵심 아이디어:

1. 배열을 내림차순 정렬
2. 상위 K개를 일단 선택하고 합계 계산
3. 만약 짝수면 바로 정답
4. 홀수인 경우:
   1. 선택한 K개 중 가장 작은 홀수 ↔ 선택하지 않은 요소 중 가장 작은 짝수 교체
   2. 선택한 K개 중 가장 작은 짝수 ↔ 선택하지 않은 요소 중 가장 작은 홀수 교체
5. 가능한 교체 중 합이 가장 큰 짝수값 선택
6. 없으면 -1

시간 복잡도:

```math
O(N log N)   (정렬)
```

## 🧪 예시 입력 & 출력

```sh
입력: 4 9 8 2 6 3
출력: 18

입력: 5 6 3 4 2 5
출력: 20

입력: 7 7 7 7 7 1
출력: -1
```
